title: Java多线程抢占
date: 2015-03-25 08:35:03
tags:
- java
- 多线程
- Android
- 优化

---

## 前言 机制种类
- 抢占机制
	
	多个线程状态可以是：可运行。但是：只有一个线程是：在运行
	
	为Java多线程机制
	
- 分时机制
	
	顾名思义

<!--more-->
## I. interrupt
#### 方法来源:
`Thread`

#### 作用范围:
`wait`/`sleep`/`join`

#### 作用效果:
立即抛出`InterruptedException`

## II. wait
#### 方法来源:
`Object`


#### 前提:
必须在`synchronized`块下调用

#### 调用:
**对于锁的操作:** 释放锁（暂时将锁借给别程序块用）

**状态:** 并进入等待池


#### 恢复:
**促发:** 1. 调用`notify`；2. `wait(millisecond)` 在给定时间到后自动收回，如果调用`notify`将立马收回


**恢复状态:** 进入锁池

**真正恢复:** 从锁池中重新活的锁，才能回到终端现场


#### 流程图:

![](/img/javathread-1.png)

## III. sleep
#### 方法来源:
`Thread`

#### 特点:
- 不释放锁
- 时间不准确（Android还有一个系统锁的机制，会导致时间会变得无法预料）

## IV. join
#### 方法来源:
`Thread`

#### 效果:
当前线程停下来等待

#### 恢复:
另一个调用`join`方法的线程终止（`run()`方法结束）

#### 注意:
激活后是进入可运行线程队列，而不会马上运行


## V. yield
#### 方法来源:
`Thread`

#### 效果:
停止当前线程，让同等优先级线程运行

#### 注意
如果没有同等优先级的线程，`yield`将不会起作用

## VI. suspend
可能导致死锁，因此弃用

# Android 中抢占机制需要注意的地方

> Android系统锁的机制，即系统在检测到一段时间没有活跃以后，会关闭一些不必要的服务来减少资源和电量的消耗，因此这种抢占机制在服务上的线程来说是不稳定的。

> 而`AlarmManager`持有一个CPU唤醒锁，是不存在这个问题的。(因此如果要做轮询、Socket心跳之类的，推荐使用`AlarmManager`，这样才能保证时间间隔的稳定、可靠)
title: Java Synchronized
date: 2015-11-13 21:14:03
tags:
- Android
- JDK
- Java
- Synchronized
- 同步
- 偏向锁
- 轻量级锁
- 重量级锁
- 自旋

---

> 底层同步实现，都是基于CPU每次只能执行一个原语，如monitorenter、monitorexist、cas、mutex等

## 原末

#### 矛盾1:

A: 重量级锁中的阻塞 挂起线程/恢复线程: 需要转入内核态中完成，有很大的性能影响

B: 锁大多数情况都是在很短的时间执行完成

解决方案: 引入 轻量锁(通过 自旋来完成锁竞争)

<!-- more -->

#### 矛盾2:

A: 轻量级锁中的自旋: 暂用CPU时间，增加cpu的消耗(因此在多核处理器上优势更明显)

B: 如果某锁始终是被长期占用，导致自旋如果没有把握好，白白浪费CPU资源

解决方案: JDK5 中引入默认自旋次数为10(用户可以通过`-XX:PreBlockSpin`进行修改)， JDK6中更是引入了自适应自旋（如果上次自旋成功概率高，就会允许等待更长的时间（如100次自旋），如果失败率很高，那很有可能就不做自旋，直接升级为重量级锁(通过阻塞）)

#### 矛盾3:

A: 无论是轻量级锁还是重量级锁: 在进入与退出时都要通过CAS修改对象头的Mark Word来进行加锁与释放锁

B: 在一些情况下总是同一线程多次获得，此时第二次再重新做CAS修改对象头Mark Word这样的操作，有些多余

解决方案: JDK 6引入偏向锁(首次需要通过CAS修改对象头Mark Word，之后该线程再进入只需要比较对象头Mark Word的Thread ID是否与当前的一致，如果是说明已经取得锁，就不用再CAS了)

#### 矛盾4:

A: 项目中代码块中可能绝大情况下都是多线程访问

B: 每次都是先偏向锁然后过渡到轻量锁，而偏向锁能用到的又很少

解决方案: 使用`-XX:-UseBiasedLocking=false`禁用偏向锁

#### 矛盾4

A: 代码中JDK原生或其他的工具方法中带有大量的加锁

B: 实际过程中，很有可能很多加锁是无效的(如局部变量作为锁，由于每次都是新对象新锁，所以没有意义)

解决方法: 引入 锁削除(虚拟机即使编译器运行时，依据逃逸分析的数据检测到不可能存在竞争的锁，就自动将该锁消除)

#### 矛盾5

A: 为了让锁颗粒度更小，或者原生方法中带有锁，很有可能在一个频繁执行(如循环)中对某对象加锁

B: 而由于在频繁的执行中，反复的加锁和解锁，设置可能导致频繁的锁竞争，都是带来很大的性能损耗

解决方法: 引入 锁膨胀(会自动将锁的范围拓展到操作序列(如循环)外, 可以理解为将一些反复的锁合为一个锁放在他们外部)


## 基本原理

> JVM基于进入和退出的Monitor对象来实现

都是使用monitorenter与monitorexit指令实现


#### 代码块同步

> monitorenter与monitorexit在编译后对称插入代码

##### monitorenter

被插入到同步代码块之前

##### monitorexit

被插到同步代码块之后或异常处

##### 基本原理

每个对象都有关联的monitor，在线程进入到monitorenter的时候，尝试取得对象的monitor所有权，也就是获得对象锁.取得以后，就处于锁状态.

## 存储结构

#### 存在哪里?

对象头。

> 数组会多1字宽(32位: 4字节)来存储数组长度

长度 | 内容 | 说明
-|-|-
1字宽 | Mark Word | 存储对象的hashCode或锁信息等
1字宽 | Class Metadata Address | 存储对象类型数据的指针
1字宽 | Array length | 数组长度(如果是数组对象)


而我们亲爱的锁，一般只和Mark Word有关

> 锁升级是单向的: 无锁 -> 偏向锁 -> 轻量级锁 -> 重量级锁

#### 各个锁的关系以及升级情况?

> 看了很多文章，都没有很清晰的，于是有了下图

![](/img/java_synchronized.png)

---

结合: [聊聊并发（二）——Java SE1.6中的Synchronized](http://www.infoq.com/cn/articles/java-se-16-synchronized)与其他文章我存我始终存在以下问题，望童鞋们不吝赐教。

> ps: 上图中从偏向锁升向轻量锁其实也存在同样的问题。

```
假若目前对象Mark Word的Thread Id为线程A的线程Id，为偏向锁，并且偏向锁正在执行同步代码块中。此时线程B monitorenter，发现不是指向自己的Thread Id，但是为偏向锁，而此时持有偏向锁的线程A还未执行完成同步代码块，此时需要等待一个全局安全点（问题1: 等待全局安全点时，线程B应该如何？挂起？不会吧？），达到安全点后，开始撤销偏向锁: 如果持有偏向锁的线程依然活跃于同步代码块，则挂起偏向锁(问题2: 还是说那个安全点就是指连同线程A的同步代码块操作完成了？)，升级为轻量锁，线程B建立锁记录，拷贝对象头Mark Word以及将对象头Mark Word指向当前锁记录，为了更简单我们就假设此时没有第三者，那么CAS操作成功，标记为轻量级锁，线程B开始执行，执行完成后，会检查对象头的Mark Word是否还是指向当前锁记录，如果有则释放锁并唤醒被挂起的线程，如果无，则释放锁，恢复到无锁状态，到最后了我们发现 线程A被挂起以后，就始终没有被唤醒的机会，是哪里出了遗漏呢？谢谢，希望能够指出我理解的错误。
```

---

- [Java的多线程机制系列：(三）synchronized的同步原理](http://www.cnblogs.com/mengheng/p/3491304.html)
- [再说 lock-free 编程](http://www.cnblogs.com/lucifer1982/archive/2009/04/08/1431992.html)
- [聊聊并发（一）——深入分析Volatile的实现原理](http://www.infoq.com/cn/articles/ftf-java-volatile)
- [聊聊并发（二）——Java SE1.6中的Synchronized](http://www.infoq.com/cn/articles/java-se-16-synchronized)
- [深入JVM锁机制1-synchronized](http://blog.csdn.net/chen77716/article/details/6618779)
- [虚拟机中的锁优化简介（适应性自旋/锁粗化/锁削除/轻量级锁/偏向锁）](http://icyfenix.iteye.com/blog/1018932)

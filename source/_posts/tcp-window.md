title: TCP 窗口
date: 2018-01-30 18:11:03
updated: 2018-01-30
categories:
- 网络
tags:
- tcp
- cwnd
- rwnd
- 拥塞算法

---

{% note info %} 这块的整理归根于FileDownloader开源库中，发现一个问题，在发起一个HTTP请求后，只读取其头部，不主动读取输入流的情况下，抓包发现，莫名的下载了一小部分内容，研究后发现，这块的资源是由于底层TCP在窗口中缓存的，而为什么需要存在这个窗口呢? {% endnote %}

<!-- more -->

### I. 为什么需要窗口

解决问题: TCP是以报文段(若干字节)为单位，每一个报文段需要一次ACK确认收到，但是其带来的问题很明显，频繁的发送确认等待导致用于确认与等待的时间太长。

解决方案: 引入窗口，ACK以窗口为单位，引入以后，发送端在发送窗口内一次可以发送几个报文段，甚至是连续的发送几个报文段而无需等待ACK

#### 什么是报文段

根据MSS，TCP认为最合适的分割数据的大小，作为若干个字节的合集，作为一个单位，也可以称为一个分组

### II. 滑动窗口(rwnd)与拥塞窗口(cwnd)差别

- 滑动窗口: 接收端的缓存大小 --- 接收方的流量控制
- 拥塞窗口: 在一个RTT内可以最多一次可发送的报文段数 --- 发送方的流量控制
- 拥塞窗口与滑动窗口共同决定了发送端的发送窗口，发送窗口每次都是取拥塞窗口与滑动窗口中的最小值

### III. 滑动窗口目的

作为流控措施，防止发送端发送过快接收端被淹没

### IV. 滑动窗口是否允许变化

允许，这个是接收端的缓存大小，每次ACK都可能带上新的接收端缓存大小作为新的可用的滑动窗口大小

### V. 什么时候告知滑动窗口大小

在ACK的时候，ACK发送两块数据:

- 告知接下来要从哪个字节的序号开始接收
- 当前的滑动窗口大小


### VI. 有滑动窗口了，为什么还要拥塞窗口

发送方与接收方之间存在多个路由器和速率较慢的链路时，一些中间路由器就必须缓存分组，并可能耗尽缓存，此时便会出现拥塞，这将严重降低了TCP连接的吞吐量，拥塞窗口就是为了防止过多的数据注入到网络中，中间路由无法消化的问题。

TCP的做法是引入`拥塞窗口(cwnd)`并策略性的调整其大小，让`发送窗口大小`取`滑动窗口与拥塞窗口的最小值，来缓解该问题，下面是拥塞窗口大小变化的策略:

#### 1. 慢开始、拥塞控制

![image_1c5324un1stt126u18pqqo1ramm.png-55.2kB][1]

其目的是: 拥塞发生时循序减少主机发送到网络的报文数，使得这时路由器有足够的时间消化积压的报文。

- 当主机开发发送数据时，`拥塞窗口(cwnd)`被初始化为1个报文段，试探性的发送1个字节的报文
- 每收到一个ACK，拥塞窗口大小就指数的增加报文段数目(1,2,4,16...)
- 最终到达提前预设的`慢开始阀值(ssthresh)`，停止使用`慢开始`算法，改用`拥塞避免算法`
- `拥塞避免算法`是每经过一个RTT，拥塞窗口就增加一个报文段，即改为线性的增加报文段
- 最终会出现网络拥塞，比如丢包等情况，停止`拥塞避免算法`，将慢开始阀值设置为目前拥塞时拥塞窗口大小的一半，并重置拥塞窗口大小为1个报文段，开始新的一轮`慢开始`

#### 2. 快重传，快恢复

![image_1c532dt06b9pfuvu2242sk4u13.png-57.6kB][2]

接收方: 如果一个包丢失，后续的包继续发送针对该包的重传请求

发送方一旦收到三个一样的确认，判定为拥塞:

- 立即重传该包
- 开始执行`快恢复`算法
- `快恢复`是`慢开始阀值`设置为目前拥塞时拥塞窗口大小的一半；拥塞窗口大小设置为目前设置后的`慢开始阀值`的大小；执行`拥塞避免算法`

其目的是: 减少因为拥塞导致的数据包丢失的重传时间，避免无用的数据到网络

### VII. 如果防止频繁的发送与确认

单个发送字节，然后等待一个确认，再发送一个字节，这样为一个字节添加40个字节头的做法，无疑增加了网络中许多不必要的报文

#### 该问题TCP层的解决方案

发送方采用`Nagle`算法:

- 若应用层是逐个字节把数据送到TCP，那么TCP不会逐个的发送，而是先发送第一个数据字节，然后缓存剩余的
- 在收到第一个字节的ACK获知网络情况与滑动窗口大小后，把缓存的剩余字节组成合适的报文发送出去
- 到达的数据达到发送窗口大小的一半或者报文段的最大长度时，立即发送

接收方的做法:

等待本地有足够的缓存空间容纳一个报文段，或者等到本地的缓存空间有一半空闲的时候，再通知发送端发送数据。

### VIII.案例

![image_1c52u2f101rp8apc1llk119n1i909.png-86.3kB][3]

#### TCP窗口特殊情况

防止丢包导致发送端停留在上次收到的滑动窗口大小为0的情况:

- 接收端B: 我的缓存已满，滑动窗口为0
- 发送端A: 停止发送数据, **并启动持续计时器(Persistence timer)**
- 接收端B: 消化完缓存，发送报文给发送端A，我的滑动窗口大小为400，但是 **这个报文丢了**
- 发送端A: **计时器时间到，发送一个1字节的探测报文**
- 接收端B: 重新发送，滑动窗口大小为400
- 发送端A: 继续发送数据

---

- [TCP的滑动窗口与拥塞窗口](http://blog.csdn.net/zhangdaisylove/article/details/47294315)
- [计算机网络【七】：可靠传输的实现 ](http://blog.chinaunix.net/uid-26275986-id-4109679.html)
- [TCP窗口控制、流控制、拥塞控制](http://blog.csdn.net/cloud323/article/details/77481711)


  [1]: /img/tcp-window-1.png
  [2]: /img/tcp-window-2.png
  [3]: /img/tcp-window-3.png
